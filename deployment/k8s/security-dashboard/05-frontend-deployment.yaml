# Security Dashboard Frontend Deployment
# React application served by nginx with security headers
apiVersion: apps/v1
kind: Deployment
metadata:
  name: security-dashboard-frontend
  namespace: security-dashboard
  labels:
    app.kubernetes.io/name: security-dashboard-frontend
    app.kubernetes.io/part-of: security-dashboard
    app.kubernetes.io/component: frontend
    app.kubernetes.io/version: "${IMAGE_TAG:-latest}"
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: security-dashboard-frontend
  template:
    metadata:
      labels:
        app.kubernetes.io/name: security-dashboard-frontend
        app.kubernetes.io/part-of: security-dashboard
        app.kubernetes.io/component: frontend
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: "/metrics"
    spec:
      serviceAccountName: security-dashboard-frontend
      securityContext:
        runAsNonRoot: true
        runAsUser: 1001
        runAsGroup: 1001
        fsGroup: 1001
      containers:
      - name: frontend
        image: ${ECR_REGISTRY}/security-dashboard-security-dashboard-frontend:${IMAGE_TAG}
        imagePullPolicy: Always
        ports:
        - name: http
          containerPort: 8080
          protocol: TCP
        - name: https
          containerPort: 8443
          protocol: TCP
        env:
        - name: API_URL
          valueFrom:
            configMapKeyRef:
              name: security-dashboard-config
              key: api-url
        - name: WS_URL
          valueFrom:
            configMapKeyRef:
              name: security-dashboard-config
              key: websocket-url
        - name: NGINX_ENVSUBST_OUTPUT_DIR
          value: /etc/nginx/conf.d
        - name: NGINX_ENVSUBST_TEMPLATE_DIR
          value: /etc/nginx/templates
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /health
            port: http
          initialDelaySeconds: 10
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /health
            port: http
          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
        startupProbe:
          httpGet:
            path: /health
            port: http
          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 12
        volumeMounts:
        - name: nginx-config
          mountPath: /etc/nginx/conf.d
          readOnly: true
        - name: logs
          mountPath: /var/log/nginx
        - name: tmp
          mountPath: /tmp
        - name: cache
          mountPath: /var/cache/nginx
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL
      volumes:
      - name: nginx-config
        configMap:
          name: nginx-config
      - name: logs
        emptyDir:
          sizeLimit: 1Gi
      - name: tmp
        emptyDir:
          sizeLimit: 100Mi
      - name: cache
        emptyDir:
          sizeLimit: 100Mi
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app.kubernetes.io/name
                  operator: In
                  values:
                  - security-dashboard-frontend
              topologyKey: kubernetes.io/hostname
      tolerations:
      - key: "node.kubernetes.io/not-ready"
        operator: "Exists"
        effect: "NoExecute"
        tolerationSeconds: 300
      - key: "node.kubernetes.io/unreachable"
        operator: "Exists"
        effect: "NoExecute"
        tolerationSeconds: 300

---
apiVersion: v1
kind: Service
metadata:
  name: security-dashboard-frontend
  namespace: security-dashboard
  labels:
    app.kubernetes.io/name: security-dashboard-frontend
    app.kubernetes.io/part-of: security-dashboard
    app.kubernetes.io/component: frontend
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "8080"
    prometheus.io/path: "/metrics"
spec:
  type: ClusterIP
  ports:
  - name: http
    port: 80
    targetPort: http
    protocol: TCP
  - name: https
    port: 443
    targetPort: https
    protocol: TCP
  selector:
    app.kubernetes.io/name: security-dashboard-frontend

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: security-dashboard-frontend
  namespace: security-dashboard
  labels:
    app.kubernetes.io/name: security-dashboard-frontend
    app.kubernetes.io/part-of: security-dashboard
    app.kubernetes.io/component: frontend
automountServiceAccountToken: false

---
# Nginx Configuration ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
  namespace: security-dashboard
  labels:
    app.kubernetes.io/name: security-dashboard-frontend
    app.kubernetes.io/part-of: security-dashboard
    app.kubernetes.io/component: frontend
data:
  default.conf: |
    # Security Dashboard Frontend - nginx configuration
    # Production-ready with security headers and performance optimization
    
    upstream backend_api {
        server security-dashboard-backend:4000;
        keepalive 32;
    }
    
    upstream graphql_gateway {
        server security-dashboard-graphql:4000;
        keepalive 32;
    }
    
    # Rate limiting zones
    limit_req_zone $binary_remote_addr zone=frontend:10m rate=100r/m;
    limit_req_zone $binary_remote_addr zone=api:10m rate=200r/m;
    
    # Cache zones
    proxy_cache_path /tmp/nginx_cache levels=1:2 keys_zone=static_cache:10m max_size=100m inactive=60m use_temp_path=off;
    
    server {
        listen 8080;
        server_name _;
        root /usr/share/nginx/html;
        index index.html;
        
        # Security headers
        add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-Frame-Options "DENY" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;
        add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self' data:; connect-src 'self' https: wss:; frame-ancestors 'none';" always;
        add_header Permissions-Policy "camera=(), microphone=(), geolocation=(), payment=(), usb=(), vr=(), accelerometer=(), gyroscope=(), magnetometer=()" always;
        
        # Hide server information
        server_tokens off;
        more_clear_headers 'Server';
        
        # Compression
        gzip on;
        gzip_vary on;
        gzip_min_length 1024;
        gzip_proxied any;
        gzip_comp_level 6;
        gzip_types
            text/plain
            text/css
            text/xml
            text/javascript
            application/json
            application/javascript
            application/xml+rss
            application/atom+xml
            image/svg+xml;
        
        # Static assets caching
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
            add_header Vary "Accept-Encoding";
            
            # Apply rate limiting
            limit_req zone=frontend burst=50 nodelay;
        }
        
        # API proxy
        location /api {
            limit_req zone=api burst=100 nodelay;
            
            proxy_pass http://backend_api;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header Connection keep-alive;
            
            # Timeouts
            proxy_connect_timeout 5s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;
            
            # Buffer settings
            proxy_buffering on;
            proxy_buffer_size 4k;
            proxy_buffers 8 4k;
        }
        
        # GraphQL proxy
        location /graphql {
            limit_req zone=api burst=100 nodelay;
            
            proxy_pass http://graphql_gateway;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # WebSocket support
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
        }
        
        # WebSocket subscriptions
        location /subscriptions {
            proxy_pass http://backend_api;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # WebSocket specific timeouts
            proxy_read_timeout 86400s;
            proxy_send_timeout 86400s;
        }
        
        # Health check endpoint
        location /health {
            access_log off;
            return 200 '{"status":"healthy","timestamp":"$time_iso8601"}';
            add_header Content-Type application/json;
        }
        
        # Main SPA route
        location / {
            limit_req zone=frontend burst=50 nodelay;
            
            try_files $uri $uri/ /index.html;
            
            # SPA specific headers
            add_header Cache-Control "no-cache, no-store, must-revalidate";
            add_header Pragma "no-cache";
            add_header Expires "0";
        }
        
        # Error pages
        error_page 404 /index.html;
        error_page 500 502 503 504 /50x.html;
        
        location = /50x.html {
            root /usr/share/nginx/html;
            internal;
        }
    }
    
    # HTTPS server (when TLS is enabled)
    server {
        listen 8443 ssl http2;
        server_name _;
        root /usr/share/nginx/html;
        index index.html;
        
        # SSL configuration
        ssl_certificate /etc/ssl/certs/tls.crt;
        ssl_certificate_key /etc/ssl/private/tls.key;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256;
        ssl_prefer_server_ciphers off;
        ssl_session_cache shared:SSL:10m;
        ssl_session_timeout 10m;
        
        # Include all HTTP server configuration
        include /etc/nginx/conf.d/security-headers.conf;
        include /etc/nginx/conf.d/proxy-settings.conf;
    }

---
# Horizontal Pod Autoscaler
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: security-dashboard-frontend-hpa
  namespace: security-dashboard
  labels:
    app.kubernetes.io/name: security-dashboard-frontend
    app.kubernetes.io/part-of: security-dashboard
    app.kubernetes.io/component: frontend
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: security-dashboard-frontend
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 10
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
      selectPolicy: Max

---
# Pod Disruption Budget
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: security-dashboard-frontend-pdb
  namespace: security-dashboard
  labels:
    app.kubernetes.io/name: security-dashboard-frontend
    app.kubernetes.io/part-of: security-dashboard
    app.kubernetes.io/component: frontend
spec:
  minAvailable: 2
  selector:
    matchLabels:
      app.kubernetes.io/name: security-dashboard-frontend