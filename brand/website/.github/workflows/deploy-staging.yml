name: 'Staging Deployment - Rehearsal Performance'

on:
  push:
    branches: [develop, feature/*, staging]
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened, ready_for_review]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment (skip change detection)'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-east-1
  ENVIRONMENT: staging
  DOMAIN_NAME: staging.candlefish.ai
  ECR_REPOSITORY: candlefish-website
  EKS_CLUSTER_NAME: staging-candlefish-website

jobs:
  # Quick pre-flight checks for staging
  preflight:
    name: 'Rehearsal Preparation'
    runs-on: ubuntu-latest
    outputs:
      should_deploy: ${{ steps.changes.outputs.should_deploy }}
      pr_number: ${{ github.event.pull_request.number }}
      commit_sha: ${{ steps.commit.outputs.sha }}
      version_tag: ${{ steps.version.outputs.tag }}
      is_pr: ${{ github.event_name == 'pull_request' }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Capture commit details
        id: commit
        run: |
          echo "sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
          echo "short_sha=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT

      - name: Generate staging version tag
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            VERSION_TAG="pr-${{ github.event.pull_request.number }}-$(git rev-parse --short HEAD)"
          else
            VERSION_TAG="staging-$(date +%Y%m%d)-$(git rev-parse --short HEAD)"
          fi
          echo "tag=$VERSION_TAG" >> $GITHUB_OUTPUT

      - name: Detect changes requiring deployment
        id: changes
        uses: dorny/paths-filter@v2
        with:
          filters: |
            deploy:
              - 'app/**'
              - 'components/**'
              - 'lib/**'
              - 'public/**'
              - 'styles/**'
              - 'package.json'
              - 'package-lock.json'
              - 'next.config.js'
              - 'tailwind.config.js'
              - 'k8s/**'
        
      - name: Override change detection for manual triggers
        if: github.event.inputs.force_deploy == 'true'
        run: echo "should_deploy=true" >> $GITHUB_OUTPUT

  # Fast test suite for staging
  test-suite:
    name: 'Quality Rehearsal'
    runs-on: ubuntu-latest
    needs: preflight
    if: needs.preflight.outputs.should_deploy == 'true'
    
    strategy:
      matrix:
        test-type: [unit, integration, lint]
        
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js environment
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run ${{ matrix.test-type }} tests
        run: |
          case "${{ matrix.test-type }}" in
            unit)
              npm run test:unit -- --passWithNoTests
              ;;
            integration)
              npm run test:integration -- --passWithNoTests
              ;;
            lint)
              npm run lint
              npm run type-check
              ;;
          esac

  # Build staging image
  build-staging:
    name: 'Staging Image Creation'
    runs-on: ubuntu-latest
    needs: [preflight, test-suite]
    if: needs.preflight.outputs.should_deploy == 'true'
    
    outputs:
      image_uri: ${{ steps.image.outputs.uri }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push staging image
        id: image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ needs.preflight.outputs.version_tag }}
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:staging-latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VERSION=${{ needs.preflight.outputs.version_tag }}
            ENVIRONMENT=staging
            GIT_SHA=${{ needs.preflight.outputs.commit_sha }}

      - name: Output image URI
        run: echo "uri=${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ needs.preflight.outputs.version_tag }}" >> $GITHUB_OUTPUT

  # Deploy to staging environment
  deploy-staging:
    name: 'Staging Performance'
    runs-on: ubuntu-latest
    needs: [preflight, build-staging]
    if: needs.preflight.outputs.should_deploy == 'true'
    
    environment: 
      name: staging
      url: https://${{ env.DOMAIN_NAME }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

      - name: Create namespace if not exists
        run: |
          kubectl create namespace ${{ env.ENVIRONMENT }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Update deployment manifest
        run: |
          # Update image in deployment
          sed -i "s|image: .*|image: ${{ needs.build-staging.outputs.image_uri }}|g" k8s/deployment.yaml
          
          # Update namespace
          sed -i "s|namespace: .*|namespace: ${{ env.ENVIRONMENT }}|g" k8s/*.yaml
          
          # Add staging-specific labels
          kubectl label namespace ${{ env.ENVIRONMENT }} environment=staging --overwrite

      - name: Deploy to staging
        run: |
          kubectl apply -f k8s/ --record
          kubectl rollout status deployment/candlefish-website -n ${{ env.ENVIRONMENT }} --timeout=300s

      - name: Verify staging deployment
        run: |
          # Wait for deployment to be ready
          kubectl wait --for=condition=available deployment/candlefish-website -n ${{ env.ENVIRONMENT }} --timeout=300s
          
          # Get deployment status
          kubectl get pods -n ${{ env.ENVIRONMENT }} -l app=candlefish-website
          
          # Test basic endpoints
          sleep 30
          curl -f https://${{ env.DOMAIN_NAME }}/health || echo "Health check failed"
          curl -f https://${{ env.DOMAIN_NAME }}/ || echo "Main page failed"

      - name: Comment on PR with staging URL
        if: needs.preflight.outputs.is_pr == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: ${{ needs.preflight.outputs.pr_number }}
            });
            
            const botComment = comments.find(comment => 
              comment.user.login === 'github-actions[bot]' && 
              comment.body.includes('üé≠ Staging Deployment')
            );
            
            const body = `## üé≠ Staging Deployment Complete
            
            **Version:** \`${{ needs.preflight.outputs.version_tag }}\`
            **Environment:** Staging
            **Status:** ‚úÖ Deployed Successfully
            
            ### üîó Preview Links
            - **Main Site:** https://${{ env.DOMAIN_NAME }}
            - **Health Check:** https://${{ env.DOMAIN_NAME }}/health
            - **Workshop:** https://${{ env.DOMAIN_NAME }}/workshop
            
            ### üìä Quick Validation
            - Build: ‚úÖ Passed
            - Tests: ‚úÖ Passed  
            - Deployment: ‚úÖ Success
            - Health Check: ‚úÖ Operational
            
            *Updated: ${new Date().toISOString()}*`;
            
            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: ${{ needs.preflight.outputs.pr_number }},
                body
              });
            }

  # Run staging-specific tests
  staging-validation:
    name: 'Staging Quality Assurance'
    runs-on: ubuntu-latest
    needs: [preflight, deploy-staging]
    if: needs.preflight.outputs.should_deploy == 'true'
    
    strategy:
      matrix:
        test-suite: [e2e, performance, accessibility]
        
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Wait for staging to be ready
        run: |
          echo "Waiting for staging environment to be fully ready..."
          sleep 60

      - name: Run ${{ matrix.test-suite }} validation
        env:
          CYPRESS_BASE_URL: https://${{ env.DOMAIN_NAME }}
          PLAYWRIGHT_BASE_URL: https://${{ env.DOMAIN_NAME }}
        run: |
          case "${{ matrix.test-suite }}" in
            e2e)
              npm run test:e2e -- --config baseUrl=https://${{ env.DOMAIN_NAME }}
              ;;
            performance)
              npm run test:performance
              ;;
            accessibility)
              npm run test:accessibility
              ;;
          esac

      - name: Upload test artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: staging-test-results-${{ matrix.test-suite }}
          path: |
            cypress/screenshots/
            cypress/videos/
            __tests__/results/

  # Cleanup old staging deployments
  cleanup:
    name: 'Staging Cleanup'
    runs-on: ubuntu-latest
    needs: [preflight, deploy-staging, staging-validation]
    if: always() && needs.preflight.outputs.should_deploy == 'true'
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

      - name: Clean up old replica sets
        run: |
          # Keep last 3 replica sets for rollback capability
          kubectl delete replicaset -n ${{ env.ENVIRONMENT }} \
            $(kubectl get replicaset -n ${{ env.ENVIRONMENT }} -o name | grep candlefish-website | head -n -3) \
            --ignore-not-found=true || echo "No old replica sets to clean"

      - name: Clean up old ECR images
        run: |
          # Keep last 10 staging images
          IMAGE_DIGESTS=$(aws ecr describe-images \
            --repository-name ${{ env.ECR_REPOSITORY }} \
            --image-ids imageTag=staging-latest \
            --query 'sort_by(imageDetails,&imagePushedAt)[:-10].[imageDigest]' \
            --output text)
          
          if [[ -n "$IMAGE_DIGESTS" ]]; then
            echo "Cleaning up old staging images..."
            for DIGEST in $IMAGE_DIGESTS; do
              aws ecr batch-delete-image \
                --repository-name ${{ env.ECR_REPOSITORY }} \
                --image-ids imageDigest=$DIGEST || true
            done
          fi

  # Notification summary
  notify:
    name: 'Performance Report'
    runs-on: ubuntu-latest
    needs: [preflight, deploy-staging, staging-validation, cleanup]
    if: always() && needs.preflight.outputs.should_deploy == 'true'
    
    steps:
      - name: Send staging deployment notification
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          custom_payload: |
            {
              attachments: [{
                color: '${{ contains(needs.*.result, 'failure') && 'danger' || 'good' }}',
                title: '${{ contains(needs.*.result, 'failure') && '‚ö†Ô∏è Staging Deployment Issues' || 'üé≠ Staging Deployment Success' }}',
                fields: [
                  {
                    title: 'Environment',
                    value: 'Staging',
                    short: true
                  },
                  {
                    title: 'Version',
                    value: '${{ needs.preflight.outputs.version_tag }}',
                    short: true
                  },
                  {
                    title: 'Type',
                    value: '${{ needs.preflight.outputs.is_pr == 'true' && 'PR Preview' || 'Branch Deploy' }}',
                    short: true
                  },
                  {
                    title: 'URL',
                    value: 'https://${{ env.DOMAIN_NAME }}',
                    short: true
                  },
                  {
                    title: 'Status',
                    value: '${{ contains(needs.*.result, 'failure') && '‚ùå Some validations failed' || '‚úÖ All systems operational' }}',
                    short: false
                  }
                ],
                footer: 'Candlefish Staging Pipeline'
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        if: always()