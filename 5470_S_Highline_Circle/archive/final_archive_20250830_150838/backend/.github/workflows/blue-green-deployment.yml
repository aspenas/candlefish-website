name: Blue-Green Production Deployment

on:
  workflow_run:
    workflows: ["Backend CI/CD Pipeline"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Docker image tag to deploy'
        required: true
        default: 'latest'
      skip_health_checks:
        description: 'Skip health checks (for emergency deployments)'
        required: false
        default: 'false'
        type: boolean
      rollback_timeout:
        description: 'Timeout for automatic rollback (seconds)'
        required: false
        default: '600'

env:
  AWS_REGION: us-east-1
  EKS_CLUSTER_NAME: inventory-cluster
  NAMESPACE: inventory-system
  APP_NAME: backend
  HEALTH_CHECK_URL: https://api.inventory.example.com/health
  SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

jobs:
  pre-deployment-checks:
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch'
    outputs:
      image-tag: ${{ steps.get-image.outputs.image-tag }}
      deployment-id: ${{ steps.deployment.outputs.deployment-id }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Get image tag
      id: get-image
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "image-tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
        else
          echo "image-tag=${{ github.sha }}" >> $GITHUB_OUTPUT
        fi

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}

    - name: Verify cluster access
      run: |
        kubectl cluster-info
        kubectl get nodes
        kubectl get namespace ${{ env.NAMESPACE }}

    - name: Check current deployment
      run: |
        kubectl get deployment ${{ env.APP_NAME }} -n ${{ env.NAMESPACE }} -o wide
        kubectl get pods -n ${{ env.NAMESPACE }} -l app=${{ env.APP_NAME }}

    - name: Create deployment
      id: deployment
      uses: actions/github-script@v7
      with:
        script: |
          const deployment = await github.rest.repos.createDeployment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: '${{ github.sha }}',
            environment: 'production',
            description: 'Blue-Green deployment to production',
            auto_merge: false,
            required_contexts: []
          });
          
          core.setOutput('deployment-id', deployment.data.id);
          
          return deployment.data.id;

    - name: Notify deployment start
      if: env.SLACK_WEBHOOK_URL
      run: |
        curl -X POST -H 'Content-type: application/json' \
          --data '{
            "text": ":rocket: Starting blue-green deployment",
            "attachments": [{
              "color": "warning",
              "fields": [
                {"title": "Environment", "value": "Production", "short": true},
                {"title": "Image", "value": "${{ steps.get-image.outputs.image-tag }}", "short": true},
                {"title": "Triggered by", "value": "${{ github.actor }}", "short": true}
              ]
            }]
          }' \
          ${{ env.SLACK_WEBHOOK_URL }}

  blue-green-deployment:
    needs: pre-deployment-checks
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://api.inventory.example.com
    timeout-minutes: 30
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}

    - name: Set deployment status to in_progress
      uses: actions/github-script@v7
      with:
        script: |
          await github.rest.repos.createDeploymentStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            deployment_id: '${{ needs.pre-deployment-checks.outputs.deployment-id }}',
            state: 'in_progress',
            description: 'Blue-green deployment in progress'
          });

    - name: Execute blue-green deployment
      id: deployment
      run: |
        chmod +x scripts/blue-green-deploy.sh
        
        # Set environment variables for deployment script
        export NEW_IMAGE="ghcr.io/${{ github.repository }}/backend:${{ needs.pre-deployment-checks.outputs.image-tag }}"
        export NAMESPACE="${{ env.NAMESPACE }}"
        export APP_NAME="${{ env.APP_NAME }}"
        export HEALTH_CHECK_URL="${{ env.HEALTH_CHECK_URL }}"
        export READINESS_TIMEOUT="${{ github.event.inputs.rollback_timeout || '600' }}"
        export ROLLBACK_ON_FAILURE="true"
        
        if [ "${{ github.event.inputs.skip_health_checks }}" = "true" ]; then
          export HEALTH_CHECK_RETRIES="1"
          export HEALTH_CHECK_INTERVAL="5"
        fi
        
        # Execute deployment
        ./scripts/blue-green-deploy.sh deploy

    - name: Upload deployment artifacts
      if: always()
      uses: actions/upload-artifact@v3
      with:
        name: deployment-report
        path: deployment-report-*.json
        retention-days: 30

    - name: Set deployment status to success
      if: success()
      uses: actions/github-script@v7
      with:
        script: |
          await github.rest.repos.createDeploymentStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            deployment_id: '${{ needs.pre-deployment-checks.outputs.deployment-id }}',
            state: 'success',
            description: 'Blue-green deployment completed successfully',
            environment_url: 'https://api.inventory.example.com'
          });

    - name: Set deployment status to failure
      if: failure()
      uses: actions/github-script@v7
      with:
        script: |
          await github.rest.repos.createDeploymentStatus({
            owner: context.repo.owner,
            repo: context.repo.repo,
            deployment_id: '${{ needs.pre-deployment-checks.outputs.deployment-id }}',
            state: 'failure',
            description: 'Blue-green deployment failed'
          });

  post-deployment-tests:
    needs: [pre-deployment-checks, blue-green-deployment]
    runs-on: ubuntu-latest
    if: success()
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        curl -sSL https://get.k6.io | sudo bash

    - name: Run smoke tests
      run: |
        # Basic API smoke tests
        echo "Testing health endpoint..."
        curl -f ${{ env.HEALTH_CHECK_URL }} || exit 1
        
        echo "Testing readiness endpoint..."
        curl -f https://api.inventory.example.com/ready || exit 1
        
        echo "Testing API functionality..."
        curl -f "https://api.inventory.example.com/api/v1/items?limit=1" || exit 1

    - name: Run load tests
      if: github.event.inputs.skip_health_checks != 'true'
      run: |
        cat > load-test.js << 'EOF'
        import http from 'k6/http';
        import { check, sleep } from 'k6';
        
        export let options = {
          stages: [
            { duration: '2m', target: 10 },
            { duration: '3m', target: 10 },
            { duration: '1m', target: 0 },
          ],
        };
        
        export default function() {
          let response = http.get('${{ env.HEALTH_CHECK_URL }}');
          check(response, {
            'status is 200': (r) => r.status === 200,
            'response time < 500ms': (r) => r.timings.duration < 500,
          });
          sleep(1);
        }
        EOF
        
        k6 run load-test.js

    - name: Performance regression check
      run: |
        # Simple performance check
        echo "Checking response times..."
        
        for i in {1..10}; do
          response_time=$(curl -w "%{time_total}" -s -o /dev/null ${{ env.HEALTH_CHECK_URL }})
          echo "Response time $i: ${response_time}s"
          
          # Fail if response time > 2 seconds
          if (( $(echo "$response_time > 2.0" | bc -l) )); then
            echo "Performance regression detected: response time > 2s"
            exit 1
          fi
        done
        
        echo "Performance check passed"

  notify-completion:
    needs: [pre-deployment-checks, blue-green-deployment, post-deployment-tests]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: Notify success
      if: needs.blue-green-deployment.result == 'success' && needs.post-deployment-tests.result == 'success'
      run: |
        if [ -n "${{ env.SLACK_WEBHOOK_URL }}" ]; then
          curl -X POST -H 'Content-type: application/json' \
            --data '{
              "text": ":white_check_mark: Blue-green deployment completed successfully",
              "attachments": [{
                "color": "good",
                "fields": [
                  {"title": "Environment", "value": "Production", "short": true},
                  {"title": "Image", "value": "${{ needs.pre-deployment-checks.outputs.image-tag }}", "short": true},
                  {"title": "Duration", "value": "${{ github.event.workflow_run.run_duration || 'N/A' }}", "short": true},
                  {"title": "URL", "value": "https://api.inventory.example.com", "short": false}
                ]
              }]
            }' \
            ${{ env.SLACK_WEBHOOK_URL }}
        fi

    - name: Notify failure
      if: needs.blue-green-deployment.result == 'failure' || needs.post-deployment-tests.result == 'failure'
      run: |
        if [ -n "${{ env.SLACK_WEBHOOK_URL }}" ]; then
          curl -X POST -H 'Content-type: application/json' \
            --data '{
              "text": ":x: Blue-green deployment failed",
              "attachments": [{
                "color": "danger",
                "fields": [
                  {"title": "Environment", "value": "Production", "short": true},
                  {"title": "Image", "value": "${{ needs.pre-deployment-checks.outputs.image-tag }}", "short": true},
                  {"title": "Failed Job", "value": "${{ needs.blue-green-deployment.result == 'failure' && 'Deployment' || 'Post-deployment Tests' }}", "short": true},
                  {"title": "Action", "value": "Manual intervention required", "short": false}
                ]
              }]
            }' \
            ${{ env.SLACK_WEBHOOK_URL }}
        fi

  cleanup:
    needs: [pre-deployment-checks, blue-green-deployment, post-deployment-tests, notify-completion]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}

    - name: Clean up old resources
      run: |
        # Clean up old ReplicaSets (keep last 3)
        kubectl get rs -n ${{ env.NAMESPACE }} -l app=${{ env.APP_NAME }} \
          --sort-by=.metadata.creationTimestamp -o name | head -n -3 | \
          xargs -r kubectl delete -n ${{ env.NAMESPACE }} --grace-period=30

    - name: Generate deployment metrics
      run: |
        echo "Collecting deployment metrics..."
        
        # Get deployment info
        kubectl get deployment ${{ env.APP_NAME }} -n ${{ env.NAMESPACE }} -o json > deployment-metrics.json
        
        # Get pod metrics
        kubectl get pods -n ${{ env.NAMESPACE }} -l app=${{ env.APP_NAME }} -o json > pod-metrics.json
        
        echo "Metrics collected"

    - name: Upload metrics
      uses: actions/upload-artifact@v3
      with:
        name: deployment-metrics
        path: "*-metrics.json"
        retention-days: 30