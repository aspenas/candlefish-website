import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate, Counter } from 'k6/metrics';

// Security testing metrics
const securityViolations = new Counter('security_violations');
const vulnerabilityCount = new Counter('vulnerability_count');
const securityTestsExecuted = new Counter('security_tests_executed');

// Test configuration for security scanning
export const options = {
  stages: [
    { duration: '2m', target: 5 },   // Low concurrent users for security tests
    { duration: '10m', target: 10 }, // Sustained security testing
    { duration: '2m', target: 0 },   // Ramp down
  ],
  
  thresholds: {
    'security_violations': ['count<10'],        // Less than 10 security violations
    'vulnerability_count': ['count==0'],        // Zero critical vulnerabilities
    'http_req_failed': ['rate<0.01'],          // Less than 1% failed requests
  },
};

// Configuration
const BASE_URL = __ENV.BASE_URL || 'http://localhost:3000';
const API_URL = __ENV.API_URL || 'http://localhost:4000';

// Common payloads for security testing
const XSS_PAYLOADS = [
  '<script>alert("XSS")</script>',
  '"><script>alert(String.fromCharCode(88,83,83))</script>',
  "';alert('XSS');//",
  '<img src=x onerror=alert("XSS")>',
  '<svg onload=alert("XSS")>',
  'javascript:alert("XSS")',
  '<iframe src="javascript:alert(`XSS`)"></iframe>',
  '<details open ontoggle=alert("XSS")>',
  '<marquee onstart=alert("XSS")>',
  '<math><mi//xlink:href="data:x,<script>alert(\'XSS\')</script>">',
];

const SQL_INJECTION_PAYLOADS = [
  "' OR '1'='1",
  "' OR 1=1--",
  "'; DROP TABLE users; --",
  "' UNION SELECT * FROM users--",
  "admin'--",
  "admin'/*",
  "' OR 1=1#",
  "' OR 'a'='a",
  "1' OR '1'='1",
  "') OR ('1'='1",
];

const NOSQL_INJECTION_PAYLOADS = [
  '{"$ne": null}',
  '{"$gt": ""}',
  '{"$regex": ".*"}',
  '{"$where": "this.username == this.password"}',
  '{"$or": [{"username": {"$ne": null}}, {"password": {"$ne": null}}]}',
];

const DIRECTORY_TRAVERSAL_PAYLOADS = [
  '../../../etc/passwd',
  '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
  '....//....//....//etc/passwd',
  '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
  '..%252f..%252f..%252fetc%252fpasswd',
];

const COMMAND_INJECTION_PAYLOADS = [
  '; cat /etc/passwd',
  '| whoami',
  '& dir',
  '`id`',
  '$(whoami)',
  '; ls -la',
  '| type %SYSTEMROOT%\\win.ini',
];

// Authentication helper
function getAuthToken(userType = 'test') {
  const credentials = {
    test: { username: 'security-test-user', password: 'test-password-123' },
    admin: { username: 'admin-user', password: 'admin-password-456' },
    guest: { username: 'guest-user', password: 'guest-password-789' },
  };
  
  const creds = credentials[userType];
  
  const response = http.post(`${API_URL}/auth/login`, JSON.stringify(creds), {
    headers: { 'Content-Type': 'application/json' },
  });
  
  if (response.status === 200) {
    return response.json('token');
  }
  
  return null;
}

// Main security test suite
export default function () {
  securityTestsExecuted.add(1);
  
  // Run different types of security tests
  testInputValidation();
  testAuthenticationSecurity();
  testAuthorizationBypass();
  testSessionManagement();
  testDataExposure();
  testErrorHandling();
  testRateLimiting();
  testSecurityHeaders();
  
  sleep(1);
}

// Test input validation and sanitization
function testInputValidation() {
  console.log('Testing input validation...');
  
  // Test XSS protection
  testXSSProtection();
  
  // Test SQL injection protection
  testSQLInjectionProtection();
  
  // Test NoSQL injection protection
  testNoSQLInjectionProtection();
  
  // Test directory traversal protection
  testDirectoryTraversalProtection();
  
  // Test command injection protection
  testCommandInjectionProtection();
}

function testXSSProtection() {
  const token = getAuthToken('test');
  if (!token) return;
  
  // Test XSS in various input fields
  const endpoints = [
    '/api/incidents',
    '/api/alerts',
    '/api/threats',
    '/api/users/profile',
  ];
  
  endpoints.forEach(endpoint => {
    XSS_PAYLOADS.forEach((payload, index) => {
      const testData = {
        title: payload,
        description: payload,
        name: payload,
        notes: payload,
      };
      
      const response = http.post(`${API_URL}${endpoint}`, JSON.stringify(testData), {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
      });
      
      // Check that XSS payload is not reflected or executed
      const passed = check(response, {
        [`XSS protection - ${endpoint} - payload ${index + 1}`]: (r) => {
          // Should not contain unescaped XSS payload
          const body = typeof r.body === 'string' ? r.body : JSON.stringify(r.body);
          const containsRawPayload = body.includes('<script>') && body.includes('alert');
          return !containsRawPayload;
        },
        'XSS response status acceptable': (r) => r.status >= 200 && r.status < 500,
      });
      
      if (!passed) {
        securityViolations.add(1);
        vulnerabilityCount.add(1);
      }
    });
  });
}

function testSQLInjectionProtection() {
  const token = getAuthToken('test');
  if (!token) return;
  
  // Test SQL injection in search and filter parameters
  const searchEndpoints = [
    '/api/incidents/search?q=',
    '/api/alerts?search=',
    '/api/threats?name=',
    '/api/users?email=',
  ];
  
  searchEndpoints.forEach(endpoint => {
    SQL_INJECTION_PAYLOADS.forEach((payload, index) => {
      const response = http.get(`${API_URL}${endpoint}${encodeURIComponent(payload)}`, {
        headers: { 'Authorization': `Bearer ${token}` },
      });
      
      const passed = check(response, {
        [`SQL injection protection - ${endpoint} - payload ${index + 1}`]: (r) => {
          // Should not return database error messages
          const body = typeof r.body === 'string' ? r.body.toLowerCase() : '';
          const hasDbError = body.includes('sql') || 
                           body.includes('mysql') || 
                           body.includes('postgres') || 
                           body.includes('database error') ||
                           body.includes('syntax error');
          return !hasDbError;
        },
        'SQL injection response status': (r) => r.status !== 500,
      });
      
      if (!passed) {
        securityViolations.add(1);
        vulnerabilityCount.add(1);
      }
    });
  });
}

function testNoSQLInjectionProtection() {
  const token = getAuthToken('test');
  if (!token) return;
  
  // Test NoSQL injection in JSON payloads
  NOSQL_INJECTION_PAYLOADS.forEach((payload, index) => {
    let testData;
    try {
      testData = JSON.parse(payload);
    } catch (e) {
      testData = { query: payload };
    }
    
    const response = http.post(`${API_URL}/api/incidents/search`, JSON.stringify(testData), {
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`,
      },
    });
    
    const passed = check(response, {
      [`NoSQL injection protection - payload ${index + 1}`]: (r) => {
        // Should not return all records or database errors
        const body = r.body || '';
        const suspiciousResponse = (r.status === 200 && body.length > 10000) || // Large response suggesting all records
                                 body.includes('mongo') || 
                                 body.includes('collection');
        return !suspiciousResponse;
      },
    });
    
    if (!passed) {
      securityViolations.add(1);
      vulnerabilityCount.add(1);
    }
  });
}

function testDirectoryTraversalProtection() {
  // Test directory traversal in file access endpoints
  DIRECTORY_TRAVERSAL_PAYLOADS.forEach((payload, index) => {
    const response = http.get(`${API_URL}/api/files/${payload}`, {
      headers: { 'Authorization': `Bearer ${getAuthToken('test')}` },
    });
    
    const passed = check(response, {
      [`Directory traversal protection - payload ${index + 1}`]: (r) => {
        // Should not expose system files
        const body = typeof r.body === 'string' ? r.body.toLowerCase() : '';
        const hasSystemFile = body.includes('root:') || 
                             body.includes('[boot loader]') ||
                             body.includes('# /etc/passwd') ||
                             body.includes('127.0.0.1');
        return !hasSystemFile && r.status !== 200;
      },
    });
    
    if (!passed) {
      securityViolations.add(1);
      vulnerabilityCount.add(1);
    }
  });
}

function testCommandInjectionProtection() {
  const token = getAuthToken('test');
  if (!token) return;
  
  // Test command injection in export/report endpoints
  COMMAND_INJECTION_PAYLOADS.forEach((payload, index) => {
    const testData = {
      format: `csv${payload}`,
      filename: `report${payload}.csv`,
      command: payload,
    };
    
    const response = http.post(`${API_URL}/api/reports/export`, JSON.stringify(testData), {
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`,
      },
    });
    
    const passed = check(response, {
      [`Command injection protection - payload ${index + 1}`]: (r) => {
        // Should not execute system commands
        const body = typeof r.body === 'string' ? r.body : '';
        const hasCommandOutput = body.includes('uid=') || 
                               body.includes('gid=') ||
                               body.includes('Volume in drive') ||
                               body.includes('Directory of');
        return !hasCommandOutput;
      },
    });
    
    if (!passed) {
      securityViolations.add(1);
      vulnerabilityCount.add(1);
    }
  });
}

// Test authentication security
function testAuthenticationSecurity() {
  console.log('Testing authentication security...');
  
  // Test brute force protection
  testBruteForceProtection();
  
  // Test weak password acceptance
  testPasswordPolicy();
  
  // Test session token security
  testTokenSecurity();
}

function testBruteForceProtection() {
  const attempts = 15; // Attempt to trigger rate limiting
  let successfulAttempts = 0;
  
  for (let i = 0; i < attempts; i++) {
    const response = http.post(`${API_URL}/auth/login`, JSON.stringify({
      username: 'nonexistent-user',
      password: `wrong-password-${i}`,
    }), {
      headers: { 'Content-Type': 'application/json' },
    });
    
    if (response.status !== 429 && response.status !== 423) {
      successfulAttempts++;
    }
    
    sleep(0.1); // Brief pause between attempts
  }
  
  const passed = check(successfulAttempts, {
    'brute force protection active': (attempts) => attempts < 10, // Should be rate limited
  });
  
  if (!passed) {
    securityViolations.add(1);
    vulnerabilityCount.add(1);
  }
}

function testPasswordPolicy() {
  const weakPasswords = [
    '123456',
    'password',
    'admin',
    '12345678',
    'qwerty',
    '123456789',
    'letmein',
    '1234567890',
    'football',
    'iloveyou',
  ];
  
  weakPasswords.forEach((password, index) => {
    const response = http.post(`${API_URL}/auth/register`, JSON.stringify({
      username: `test-user-${index}`,
      email: `test${index}@example.com`,
      password: password,
    }), {
      headers: { 'Content-Type': 'application/json' },
    });
    
    const passed = check(response, {
      [`weak password rejected - ${password}`]: (r) => r.status === 400 || r.status === 422,
    });
    
    if (!passed) {
      securityViolations.add(1);
    }
  });
}

function testTokenSecurity() {
  // Test JWT token manipulation
  const validToken = getAuthToken('test');
  if (!validToken) return;
  
  // Test with manipulated token
  const manipulatedTokens = [
    validToken.slice(0, -5) + 'XXXXX', // Altered signature
    'Bearer ' + validToken, // Malformed header
    validToken.replace('.', ''), // Malformed structure
    'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c', // Static token
  ];
  
  manipulatedTokens.forEach((token, index) => {
    const response = http.get(`${API_URL}/api/user/profile`, {
      headers: { 'Authorization': `Bearer ${token}` },
    });
    
    const passed = check(response, {
      [`token manipulation rejected - ${index + 1}`]: (r) => r.status === 401 || r.status === 403,
    });
    
    if (!passed) {
      securityViolations.add(1);
      vulnerabilityCount.add(1);
    }
  });
}

// Test authorization bypass
function testAuthorizationBypass() {
  console.log('Testing authorization controls...');
  
  const guestToken = getAuthToken('guest');
  const userToken = getAuthToken('test');
  
  if (!guestToken || !userToken) return;
  
  // Admin-only endpoints that should be protected
  const adminEndpoints = [
    '/api/admin/users',
    '/api/admin/settings',
    '/api/admin/audit-logs',
    '/api/admin/system-config',
  ];
  
  adminEndpoints.forEach(endpoint => {
    // Test with guest token
    const guestResponse = http.get(`${API_URL}${endpoint}`, {
      headers: { 'Authorization': `Bearer ${guestToken}` },
    });
    
    // Test with regular user token
    const userResponse = http.get(`${API_URL}${endpoint}`, {
      headers: { 'Authorization': `Bearer ${userToken}` },
    });
    
    const guestPassed = check(guestResponse, {
      [`guest access denied to ${endpoint}`]: (r) => r.status === 403 || r.status === 401,
    });
    
    const userPassed = check(userResponse, {
      [`user access denied to ${endpoint}`]: (r) => r.status === 403 || r.status === 401,
    });
    
    if (!guestPassed || !userPassed) {
      securityViolations.add(1);
      vulnerabilityCount.add(1);
    }
  });
  
  // Test horizontal privilege escalation
  testHorizontalPrivilegeEscalation(userToken);
}

function testHorizontalPrivilegeEscalation(token) {
  // Try to access other users' data
  const otherUserIds = ['user-123', 'user-456', 'user-789'];
  
  otherUserIds.forEach(userId => {
    const response = http.get(`${API_URL}/api/users/${userId}/profile`, {
      headers: { 'Authorization': `Bearer ${token}` },
    });
    
    const passed = check(response, {
      [`horizontal privilege escalation blocked - ${userId}`]: (r) => r.status === 403 || r.status === 404,
    });
    
    if (!passed) {
      securityViolations.add(1);
      vulnerabilityCount.add(1);
    }
  });
}

// Test session management
function testSessionManagement() {
  console.log('Testing session management...');
  
  const token = getAuthToken('test');
  if (!token) return;
  
  // Test session fixation
  const response = http.post(`${API_URL}/auth/login`, JSON.stringify({
    username: 'security-test-user',
    password: 'test-password-123',
  }), {
    headers: { 
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`, // Existing token
    },
  });
  
  const passed = check(response, {
    'new token issued on login': (r) => {
      const newToken = r.json('token');
      return newToken && newToken !== token;
    },
  });
  
  if (!passed) {
    securityViolations.add(1);
  }
  
  // Test concurrent sessions
  testConcurrentSessions();
}

function testConcurrentSessions() {
  const credentials = {
    username: 'security-test-user',
    password: 'test-password-123',
  };
  
  // Create multiple sessions
  const tokens = [];
  for (let i = 0; i < 5; i++) {
    const response = http.post(`${API_URL}/auth/login`, JSON.stringify(credentials), {
      headers: { 'Content-Type': 'application/json' },
    });
    
    if (response.status === 200) {
      tokens.push(response.json('token'));
    }
  }
  
  // Test if all tokens are valid simultaneously
  let validTokens = 0;
  tokens.forEach(token => {
    const response = http.get(`${API_URL}/api/user/profile`, {
      headers: { 'Authorization': `Bearer ${token}` },
    });
    
    if (response.status === 200) {
      validTokens++;
    }
  });
  
  // Should limit concurrent sessions or invalidate old ones
  const passed = check(validTokens, {
    'concurrent session management': (count) => count <= 3, // Allow max 3 concurrent sessions
  });
  
  if (!passed) {
    securityViolations.add(1);
  }
}

// Test data exposure
function testDataExposure() {
  console.log('Testing data exposure...');
  
  const token = getAuthToken('guest');
  if (!token) return;
  
  // Test for sensitive data in responses
  const endpoints = [
    '/api/public/alerts',
    '/api/public/incidents',
    '/api/public/security-status',
  ];
  
  endpoints.forEach(endpoint => {
    const response = http.get(`${API_URL}${endpoint}`, {
      headers: { 'Authorization': `Bearer ${token}` },
    });
    
    const passed = check(response, {
      [`no sensitive data exposed - ${endpoint}`]: (r) => {
        const body = typeof r.body === 'string' ? r.body.toLowerCase() : JSON.stringify(r.body).toLowerCase();
        const hasSensitiveData = body.includes('password') ||
                               body.includes('secret') ||
                               body.includes('private_key') ||
                               body.includes('api_key') ||
                               body.includes('ssn') ||
                               body.includes('credit_card');
        return !hasSensitiveData;
      },
    });
    
    if (!passed) {
      securityViolations.add(1);
      vulnerabilityCount.add(1);
    }
  });
}

// Test error handling
function testErrorHandling() {
  console.log('Testing error handling...');
  
  // Test for information disclosure in error messages
  const invalidEndpoints = [
    '/api/nonexistent-endpoint',
    '/api/users/invalid-id',
    '/api/incidents/99999999',
  ];
  
  invalidEndpoints.forEach(endpoint => {
    const response = http.get(`${API_URL}${endpoint}`, {
      headers: { 'Authorization': `Bearer ${getAuthToken('test')}` },
    });
    
    const passed = check(response, {
      [`safe error handling - ${endpoint}`]: (r) => {
        const body = typeof r.body === 'string' ? r.body.toLowerCase() : '';
        const hasInfoDisclosure = body.includes('stack trace') ||
                                body.includes('internal server error') ||
                                body.includes('database') ||
                                body.includes('file path') ||
                                body.includes('line number');
        return !hasInfoDisclosure;
      },
    });
    
    if (!passed) {
      securityViolations.add(1);
    }
  });
}

// Test rate limiting
function testRateLimiting() {
  console.log('Testing rate limiting...');
  
  const token = getAuthToken('test');
  if (!token) return;
  
  // Rapid API calls to trigger rate limiting
  const rapidRequests = 50;
  let blockedRequests = 0;
  
  for (let i = 0; i < rapidRequests; i++) {
    const response = http.get(`${API_URL}/api/threats?page=${i}`, {
      headers: { 'Authorization': `Bearer ${token}` },
    });
    
    if (response.status === 429) {
      blockedRequests++;
    }
  }
  
  const passed = check(blockedRequests, {
    'rate limiting active': (blocked) => blocked > 0,
  });
  
  if (!passed) {
    securityViolations.add(1);
  }
}

// Test security headers
function testSecurityHeaders() {
  console.log('Testing security headers...');
  
  const response = http.get(`${BASE_URL}/`);
  
  const securityHeaders = {
    'X-Content-Type-Options': 'nosniff',
    'X-Frame-Options': 'DENY',
    'X-XSS-Protection': '1; mode=block',
    'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
    'Content-Security-Policy': true, // Just check if present
    'Referrer-Policy': 'strict-origin-when-cross-origin',
  };
  
  Object.entries(securityHeaders).forEach(([header, expectedValue]) => {
    const passed = check(response, {
      [`${header} header present`]: (r) => {
        const headerValue = r.headers[header] || r.headers[header.toLowerCase()];
        if (expectedValue === true) {
          return headerValue !== undefined;
        }
        return headerValue === expectedValue;
      },
    });
    
    if (!passed) {
      securityViolations.add(1);
    }
  });
}

// OWASP ZAP integration test
export function owaspZapScan() {
  console.log('Running OWASP ZAP scan...');
  
  // This would integrate with OWASP ZAP API if available
  const zapApiUrl = __ENV.ZAP_API_URL || 'http://localhost:8080';
  
  // Start spider scan
  const spiderResponse = http.get(`${zapApiUrl}/JSON/spider/action/scan/?url=${BASE_URL}`);
  
  if (spiderResponse.status === 200) {
    const scanId = spiderResponse.json('scan');
    
    // Wait for scan completion (simplified)
    sleep(30);
    
    // Get scan results
    const resultsResponse = http.get(`${zapApiUrl}/JSON/core/view/alerts/?baseurl=${BASE_URL}`);
    
    if (resultsResponse.status === 200) {
      const alerts = resultsResponse.json('alerts') || [];
      const highRiskAlerts = alerts.filter(alert => alert.risk === 'High');
      const mediumRiskAlerts = alerts.filter(alert => alert.risk === 'Medium');
      
      check(highRiskAlerts, {
        'no high risk vulnerabilities': (alerts) => alerts.length === 0,
      });
      
      check(mediumRiskAlerts, {
        'limited medium risk vulnerabilities': (alerts) => alerts.length < 5,
      });
      
      vulnerabilityCount.add(highRiskAlerts.length + mediumRiskAlerts.length);
    }
  }
}

// Cleanup and reporting
export function teardown(data) {
  console.log('\n=== Security Vulnerability Scan Results ===');
  console.log(`Security tests executed: ${securityTestsExecuted.count}`);
  console.log(`Security violations found: ${securityViolations.count}`);
  console.log(`Vulnerabilities identified: ${vulnerabilityCount.count}`);
  
  if (vulnerabilityCount.count > 0) {
    console.log('\n⚠️  SECURITY ISSUES DETECTED ⚠️');
    console.log('Review the test results and address vulnerabilities before production deployment.');
  } else {
    console.log('\n✅ No critical vulnerabilities detected');
  }
  
  console.log('===========================================\n');
}